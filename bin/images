#!/usr/bin/env ruby

require 'yaml'
require 'json'
require 'optparse'
require 'fileutils'

class String
  def quotify
    format('"%s"', self)
  end

  def backquotify
    format('`%s`', self)
  end
end

class Image
  REPOSITORY       = 'silex/emacs'
  CACHE_REPOSITORY = 'ghcr.io/silex/emacs-cache'
  IMAGES_YML       = 'images.yml'

  attr_reader :os
  attr_reader :version
  attr_reader :subdir

  class << self
    def all
      images = []
      versions.each do |version|
        exclusion = exclusions.find { |h| h['version'] == version }
        oses.each do |os|
          next if exclusion&.dig('os')&.include?(os)
          images << Image.new(version: version, os: os, subdir: nil)
          subdirs.each do |child_subdir|
            next if exclusion&.dig('subdirs')&.include?(child_subdir)
            images << Image.new(version: version, os: os, subdir: child_subdir)
          end
        end
      end
      images
    end

    def data
      @data ||= YAML.safe_load(File.read(IMAGES_YML), symbolize_names: false)
    end

    def versions
      data['versions'].map(&:to_s)
    end

    def oses
      data['oses']
    end

    def subdirs
      Array(data['subdirs'])
    end

    def cache_bust_versions
      Array(data['cache_bust']).map(&:to_s)
    end

    def major_latests
      versions
        .reject { |v| v == 'master' }
        .group_by(&:to_i)
        .map { |_, vs| vs.sort.last }
        .sort
    end

    def exclusions
      # Ensure versions are strings
      data['exclusions'].map do |h|
        h['version'] = h['version'].to_s
        h['subdirs'] = Array(h['subdirs']).map(&:to_s) if h.key?('subdirs')
        h
      end
    end

    def github
      {
        include: github_include,
        exclude: github_exclude
      }
    end

    def github_include
      include = [{ subdirs: subdirs }]
      with_excluded_subdirs = exclusions.select{ |h| h.has_key?('subdirs') }
      with_excluded_subdirs.each do |h|
        include << { version: h['version'], subdirs: subdirs - h['subdirs'] }
      end
      include
    end

    def github_exclude
      with_excluded_os = exclusions.select{ |h| h.has_key?('os') }
      with_excluded_os.flat_map do |h|
        h['os'].map do |os|
          { version: h['version'], os: os }
        end
      end
    end

    def to_json
      {
        versions: versions,
        oses: oses,
        subdirs: subdirs,
        exclusions: exclusions,
        cache_bust: cache_bust_versions,
        github: github,
        images: all
      }.to_json
    end
  end

  def initialize(version:, os:, subdir:)
    @version = version
    @os      = os
    @subdir  = subdir
  end

  def major_latest?
    self.class.major_latests.include?(version)
  end

  def latest?
    self.class.major_latests.last == version
  end

  def tags
    tag_variants.flat_map { |variant| tags_for_variant(variant) }
  end

  def tags_with_repository
    tags.map do |s|
      format('%s:%s', REPOSITORY, s)
    end
  end

  def cache
    format('%s:%s', CACHE_REPOSITORY, tags.first)
  end

  # Returns the corresponding Nix version.
  def nix_version
    return 'emacs-snapshot' if version == 'master'
    format('emacs-%s', version.gsub('.', '-'))
  end

  def directory
    parts = [version, os, subdir].compact
    File.join('images', *parts)
  end

  def dockerfile
    File.join(directory, 'Dockerfile')
  end

  def template
    return File.join('templates', os, 'Dockerfile') unless subdir

    File.join('templates', os, subdir, 'Dockerfile')
  end

  def depends
    return nil unless subdir

    parent = self.class.new(version: version, os: os, subdir: parent_subdir)
    parent.tags_with_repository.first
  end

  def parent_subdir
    return nil unless subdir

    parent, _sep, _leaf = subdir.rpartition('/')
    parent.empty? ? nil : parent
  end

  def tag_variants
    return [nil] unless subdir

    segments = subdir.split('/')
    (0...segments.length).map { |i| segments[i..-1].join('-') }
  end

  def tags_for_variant(variant)
    tags = [tag_with_os(variant)]
    tags << tag_pretty(variant) if os == 'debian'

    if major_latest?
      tags += tags.map { |t| t.sub(/\.\d+/, '') }
      tags << latest_tag(variant) if latest?
    end

    tags
  end

  def tag_with_os(variant)
    return format('%s-%s', version, os) unless variant

    format('%s-%s-%s', version, os, variant)
  end

  def tag_pretty(variant)
    return version unless variant

    format('%s-%s', version, variant)
  end

  def latest_tag(variant)
    if os == 'debian'
      return 'latest' unless variant

      return variant
    end

    return os unless variant

    format('%s-%s', os, variant)
  end

  def to_json(options = nil)
    {
      version: version,
      os: os,
      subdir: subdir,
      nix_version: nix_version,
      directory: directory,
      dockerfile: dockerfile,
      tags: tags,
      tags_with_repository: tags_with_repository,
      cache: cache,
      depends: depends,
      cache_bust: self.class.cache_bust_versions.include?(version),
      major_latest?: major_latest?,
      latest?: latest?,
    }.to_json
  end
end

def generate_dockerfiles(images)
  puts '>>> generating dockerfiles'
  images.map(&:directory).uniq.each { |path| FileUtils.rm_rf(path) }

  images.each do |image|
    FileUtils.mkdir_p(image.directory)
    content = File.read(image.template)
    content.gsub!('{{NIX_VERSION}}', image.nix_version)
    if Image.cache_bust_versions.include?(image.version)
      cache_bust = 'ADD https://api.github.com/repos/purcell/nix-emacs-ci/commits?per_page=1 /tmp/cache'
      content.gsub!(/\n{{CACHE_BUST}}/, "\n#{cache_bust}")
    else
      content.gsub!(/\n{{CACHE_BUST}}/, '')
    end
    content.gsub!('{{DEPENDS}}', image.depends) if image.depends
    File.write(image.dockerfile, content)
  end
end

def generate_readme(images)
  puts '>>> generating README.md'
  # Group by version and reverse the order if needed
  tags = images.group_by(&:version).values.reverse.flatten.flat_map do |image|
    format('- [%s](https://github.com/Silex/docker-emacs/blob/main/%s)',
           image.tags.map(&:backquotify).join(', '),
           image.dockerfile)
  end

  readme = File.join('templates', 'README.md')
  unless File.exist?(readme)
    warn "README template not found at #{readme}"
    return
  end

  template_content = File.read(readme)
  content = template_content.dup
  content.gsub!('{{TAGS}}', tags.join("\n"))
  File.write('README.md', content)

  # Docker Hub description: only keep master + latest for each major (25,000 bytes description limit).
  latest_versions = Image.major_latests
  short_tags = images.select do |image|
    image.version == 'master' || latest_versions.include?(image.version)
  end
  short_tags = short_tags.group_by(&:version).values.reverse.flatten.flat_map do |image|
    format('- [%s](https://github.com/Silex/docker-emacs/blob/main/%s)',
           image.tags.map(&:backquotify).join(', '),
           image.dockerfile)
  end

  dockerhub_content = template_content.dup
  dockerhub_content.gsub!('{{TAGS}}', short_tags.join("\n"))
  dockerhub_content.sub!('# Tags', "# Tags\n\nFull image list: https://github.com/Silex/docker-emacs#tags")
  File.write('README.dockerhub.md', dockerhub_content)
end

def run(options)
  if options[:generate]
    images = Image.all
    generate_dockerfiles(images)
    generate_readme(images)
  end

  puts Image.to_json if options[:json]
end

def parse_options
  options = {}
  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: images [options]'
    opts.separator ''
    opts.separator 'Generate the Dockerfiles & README or return images JSON.'

    opts.on('--generate', 'Generate Dockerfiles and README') do
      options[:generate] = true
    end

    opts.on('--json', 'Output images as JSON') do
      options[:json] = true
    end

    opts.on('-h', '--help', 'Print usage') do
      puts opts
      exit
    end
  end

  begin
    parser.parse!
  rescue OptionParser::InvalidOption => e
    warn e.message
    puts parser
    exit(1)
  end

  if options.empty?
    puts parser
    exit(1)
  end

  options
end

def main
  options = parse_options
  Dir.chdir(File.expand_path('..', __dir__)) do
    run(options)
  end
end

main
