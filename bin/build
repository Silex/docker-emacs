#!/usr/bin/env ruby

require 'json'
require 'optparse'

def build(options)
  os, version, subdirs = options.values_at(:os, :version, :subdirs)
  subdirs = parse_subdirs(subdirs)
  images = load_images.select { |img| img.values_at('os', 'version') == [os, version] }
  root = images.find { |img| img['subdir'].nil? }
  subdir_index = index_by_subdir(images)
  build_subdirs = build_order(subdirs, subdir_index.keys)
  build_list = [root] + build_subdirs.map { |subdir| subdir_index.fetch(subdir) }

  build_list.each do |image|
    build_image(image)
  end
end

def load_images
  command = format('%s/images --json', File.expand_path(__dir__))
  json = `#{command}`.strip
  abort 'Failed to retrieve images' if json.empty?
  data = JSON.parse(json)
  data['images']
end

def index_by_subdir(images)
  images.each_with_object({}) do |image, index|
    subdir = image['subdir']
    next if subdir.nil?
    index[subdir] = image
  end
end

def build_image(image)
  puts format('----------------------------------------------------------------------')

  source_date_epoch = read_source_date_epoch(image['dockerfile'])

  args = %w[docker buildx build --progress plain]

  # Only pull first image
  args << '--pull' if image['subdir'].nil?

  if ENV['GITHUB_REF_NAME'] == 'main'
    args << '--provenance=false'
    args << '--sbom=false'
    args << '--cache-from' << format('type=registry,ref=%s', image['cache'])
    args << '--cache-to' << format('type=registry,ref=%s,mode=max', image['cache'])
    output = ['type=image', "\"name=#{image['tags_with_repository'].join(',')}\"", 'push=true', 'rewrite-timestamp=true']
    args << '--output' << output.join(',')
  else
    args << '--load'
    args += image['tags_with_repository'].flat_map { |s| ['--tag', s] }
  end

  args << image['directory']

  # Build image
  puts format('>>> Running command: %s', args.join(' '))
  env = { 'SOURCE_DATE_EPOCH' => source_date_epoch }
  system(env, *args) || abort('Build failed')
end

def parse_subdirs(subdirs)
  return [] if subdirs.nil?

  subdirs.split(',').map(&:strip).reject(&:empty?)
end

def parent_paths(subdir)
  parts = subdir.split('/')
  parents = []
  1.upto(parts.length - 1) do |i|
    parents << parts[0, i].join('/')
  end
  parents
end

def build_order(subdirs, available_subdirs)
  return [] if subdirs.empty?

  index = available_subdirs.each_with_index.to_h
  required = []
  subdirs.each do |subdir|
    required << subdir
    required.concat(parent_paths(subdir))
  end
  required = required.uniq
  unknown = required.reject { |subdir| index.key?(subdir) }
  abort format('Unknown subdir: %s', unknown.join(', ')) unless unknown.empty?

  required.sort_by { |subdir| [subdir.count('/'), index[subdir]] }
end

def read_source_date_epoch(path)
  repo_root = File.expand_path('..', __dir__)
  epoch = IO.popen(['git', '-C', repo_root, 'log', '-1', '--format=%ct', '--', path], &:read).strip
  return epoch unless epoch.empty?

  abort format('No git history found for %s. Ensure full git history is available (e.g., checkout with fetch-depth: 0).', path)
end

def parse_options
  options = {}

  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: build --os OS --version VERSION --subdirs SUBDIRS'
    opts.separator ''
    opts.separator 'Build an image'

    opts.on('--os OS', 'Image OS (required)') do |os|
      options[:os] = os
    end

    opts.on('--version VERSION', 'Image VERSION (required)') do |version|
      options[:version] = version
    end

    opts.on('--subdirs SUBDIRS', 'Image SUBDIRS (required)') do |subdirs|
      options[:subdirs] = subdirs
    end

    opts.on('-h', '--help', 'Print usage') do
      puts opts
      exit
    end
  end

  begin
    parser.parse!
  rescue OptionParser::InvalidOption => e
    STDERR.puts e.message
    STDERR.puts parser
    exit 1
  end

  # Check that all required options are present
  missing = []
  missing << '--os' unless options[:os]
  missing << '--version' unless options[:version]
  missing << '--subdirs' unless options[:subdirs]

  unless missing.empty?
    STDERR.puts "Missing required option(s): #{missing.join(', ')}"
    STDERR.puts parser
    exit 1
  end

  options
end

def main
  options = parse_options
  build(options)
end

main
