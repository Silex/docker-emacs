#!/usr/bin/env ruby

require 'json'
require 'optparse'

def build(options)
  command = format('%s/images --json', File.expand_path(__dir__))
  json = `#{command}`.strip
  abort 'Failed to retrieve images' if json.empty?
  images = JSON.parse(json)['images']
  os, version, targets = options.values_at(:os, :version, :targets)
  targets = targets.split(',')

  targets.each_with_index do |target, i|
    image = images.find { |img| img.values_at('os', 'version', 'target') == [os, version, target] }
    abort 'Could not find image' unless image

    args = %w[docker buildx build]

    # Common arguments
    args << '--target' << target
    args << '--build-arg' << format('NIX_VERSION=%s', image['nix_version'])
    args.concat(image['tags_with_repository'].flat_map { |s| ['--tag', s] })
    args << '--cache-from' << format('type=registry,ref=%s', image['cache'])

    # Conditional arguments
    args << '--pull' if i == 0 # only pull first target
    args << '--push' if ENV['GITHUB_REF_NAME'] == 'master' # push master branch
    args << '--cache-to' << format('type=registry,ref=%s,mode=max', image['cache']) if i == (targets.size - 1) # only cache last target

    args << image['context']

    # Build image
    puts format('>>> Running command: %s', args.join(' '))
    system(*args) || abort('Build failed')

    # Check if image runs properly
    command = format('docker run --rm %s emacs --version', image['tags_with_repository'].first)
    system(command) || abort('Image does not work')
  end
end

def parse_options
  options = {}

  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: build --os OS --version VERSION --targets TARGETS'
    opts.separator ''
    opts.separator 'Build an image'

    opts.on('--os OS', 'Image OS (required)') do |os|
      options[:os] = os
    end

    opts.on('--version VERSION', 'Image VERSION (required)') do |version|
      options[:version] = version
    end

    opts.on('--targets TARGETS', 'Image TARGETS (required)') do |targets|
      options[:targets] = targets
    end

    opts.on('-h', '--help', 'Print usage') do
      puts opts
      exit
    end
  end

  begin
    parser.parse!
  rescue OptionParser::InvalidOption => e
    STDERR.puts e.message
    STDERR.puts parser
    exit 1
  end

  # Check that all required options are present
  missing = []
  missing << '--os' unless options[:os]
  missing << '--version' unless options[:version]
  missing << '--targets' unless options[:targets]

  unless missing.empty?
    STDERR.puts "Missing required option(s): #{missing.join(', ')}"
    STDERR.puts parser
    exit 1
  end

  options
end

def main
  options = parse_options
  build(options)
end

main
