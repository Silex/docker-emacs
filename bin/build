#!/usr/bin/env ruby

require 'json'
require 'optparse'

def build(options)
  command = format('%s/images --json', File.expand_path(__dir__))
  json = `#{command}`.strip
  abort 'Failed to retrieve images' if json.empty?
  data = JSON.parse(json)
  images = data['images']
  os, version, subdirs = options.values_at(:os, :version, :subdirs)
  subdirs = parse_subdirs(subdirs)
  build_subdirs = build_order(subdirs, data['subdirs'])

  push = ENV['GITHUB_REF_NAME'] == 'main'
  build_list = []
  root = find_image(images, os, version, nil)
  abort 'Could not find root image' unless root
  build_list << root
  build_subdirs.each do |subdir|
    image = find_image(images, os, version, subdir)
    abort format('Could not find image for %s', subdir) unless image
    build_list << image
  end

  build_list.each do |image|
    puts format('----------------------------------------------------------------------')

    source_date_epoch = read_source_date_epoch(image['dockerfile'])

    args = %w[docker buildx build --progress plain]

    # Only pull first image
    args << '--pull' if image['subdir'].nil?

    if push
      args << '--provenance=false'
      args << '--sbom=false'
      args << '--cache-from' << format('type=registry,ref=%s', image['cache'])
      args << '--cache-to' << format('type=registry,ref=%s,mode=max', image['cache'])
      output = ['type=image', "\"name=#{image['tags_with_repository'].join(',')}\"", 'push=true', 'rewrite-timestamp=true']
      args << '--output' << output.join(',')
    else
      args << '--load'
      args += image['tags_with_repository'].flat_map { |s| ['--tag', s] }
    end

    args << image['directory']

    # Build image
    puts format('>>> Running command: %s', args.join(' '))
    env = { 'SOURCE_DATE_EPOCH' => source_date_epoch }
    system(env, *args) || abort('Build failed')
  end
end

def parse_subdirs(subdirs)
  return [] if subdirs.nil?

  subdirs.split(',').map(&:strip).reject(&:empty?)
end

def parent_paths(subdir)
  parts = subdir.split('/')
  parents = []
  1.upto(parts.length - 1) do |i|
    parents << parts[0, i].join('/')
  end
  parents
end

def build_order(subdirs, child_order)
  return [] if subdirs.empty?

  index = child_order.each_with_index.to_h
  required = []
  subdirs.each do |subdir|
    required << subdir
    required.concat(parent_paths(subdir))
  end
  required = required.uniq
  unknown = required.reject { |subdir| index.key?(subdir) }
  abort format('Unknown child directory: %s', unknown.join(', ')) unless unknown.empty?

  required.sort_by { |subdir| [subdir.count('/'), index[subdir]] }
end

def find_image(images, os, version, subdir)
  images.find { |img| img.values_at('os', 'version', 'subdir') == [os, version, subdir] }
end

def read_source_date_epoch(path)
  repo_root = File.expand_path('..', __dir__)
  epoch = IO.popen(['git', '-C', repo_root, 'log', '-1', '--format=%ct', '--', path], &:read).strip
  return epoch unless epoch.empty?

  abort format('No git history found for %s. Ensure full git history is available (e.g., checkout with fetch-depth: 0).', path)
end

def parse_options
  options = {}

  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: build --os OS --version VERSION --subdirs SUBDIRS'
    opts.separator ''
    opts.separator 'Build an image'

    opts.on('--os OS', 'Image OS (required)') do |os|
      options[:os] = os
    end

    opts.on('--version VERSION', 'Image VERSION (required)') do |version|
      options[:version] = version
    end

    opts.on('--subdirs SUBDIRS', 'Image SUBDIRS (required)') do |subdirs|
      options[:subdirs] = subdirs
    end

    opts.on('-h', '--help', 'Print usage') do
      puts opts
      exit
    end
  end

  begin
    parser.parse!
  rescue OptionParser::InvalidOption => e
    STDERR.puts e.message
    STDERR.puts parser
    exit 1
  end

  # Check that all required options are present
  missing = []
  missing << '--os' unless options[:os]
  missing << '--version' unless options[:version]
  missing << '--subdirs' unless options[:subdirs]

  unless missing.empty?
    STDERR.puts "Missing required option(s): #{missing.join(', ')}"
    STDERR.puts parser
    exit 1
  end

  options
end

def main
  options = parse_options
  build(options)
end

main
